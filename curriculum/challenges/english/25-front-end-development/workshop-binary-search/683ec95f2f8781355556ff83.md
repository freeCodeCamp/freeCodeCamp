---
id: 683ec95f2f8781355556ff83
title: Step 11
challengeType: 20
dashedName: step-11
---

# --description--

You can see that the first call returns `[3]`, which is the direct and sole middle value in the `search_list`. Why? Because the `search_list` passed has a total of five elements, an odd number in which the middle index is `2`, and the value at that index is `3`.

The second call, on the other hand, returns `This shows because the value is farther than the middle value to the right or left`, because the loop runs only once for now and stops immediately after checking the middle value.

This is how the binary search algorithm works. It compares your target with the middle of the list, then limits the search range in half based on whether the target value is smaller or larger. Since the loop only runs once, it behaves more like a single midpoint check, not a full search.

To fix that, start by working on the next condition. First, remove the `break` keyword.

# --hints--

Test 1

```js

```

# --seed--

## --seed-contents--

```py
def binary_search(search_list, value):
    path_to_target = []
    low = 0
    high = len(search_list) - 1
    
    while low <= high:
        mid = (low + high) // 2
        value_at_middle = search_list[mid]
        path_to_target.append(value_at_middle)

        if value == value_at_middle:
          return path_to_target
--fcc-editable-region--
        break
--fcc-editable-region--          
    return "This shows because the value is farther than the middle value to the right or left"

print(binary_search([1, 2, 3, 4, 5], 3))
print(binary_search([1, 2, 3, 4, 5, 9], 4)) 
```
