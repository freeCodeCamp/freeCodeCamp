---
id: 6895d06b5968736797c408e3
title: What Are Good Problem-Solving Techniques and Ways to Approach Algorithmic Challenges?
challengeType: 19
dashedName: what-are-good-problem-solving-techniques-and-ways-to-approach-algorithmic-challenges
---

# --description--

During your learning journey, you should work on developing strong problem-solving skills. These core skills will be essential for tackling real-world problems in your daily work.

Solving algorithmic challenges is a great way to practice. It requires an analytical way of thinking, being able to break the problem down into its core components, and finding a solution that generates the right output efficiently.

But where do you start?

There are several problem-solving techniques that you can use to start approaching these challenges.

As an example, we'll reverse a string in Python.

This is the challenge:

"Given a string, write an algorithm that returns a new string with the characters in reverse order."

The first thing that you should do when you come across this type of problem is to read the description multiple times to make sure that you understand what it says. You may miss critical information if you skip this step or read it too fast.

Then, once you are familiar with the problem, start breaking it down into its core components.

Ask yourself:

* "What is the input?"
    
* "What is the expected output?"
    
* "How can I transform the input into the expected output?"
    

In this problem, you can determine that the input is a string because the challenge starts with "Given a string…"

The output is "a new string with the characters in reverse order."

So you need to take the original string and reverse it.

This initial analysis might seem a bit repetitive at first, but it's very helpful to make sure that you fully understand the requirements.

Then, you should start thinking about how the algorithm that you will develop will transform the input into the output.

During this planning and analysis phase, it's common to use pseudocode to map out the necessary steps.

**Pseudocode** is a high-level description of the algorithm's logic that is general in nature, and is not based on any specific programming language.

Pseudocode is not as formal as actual code, since it's only intended for humans to read. It should be easy to understand at a glance. Its main purpose is to give a clear idea of the sequence of steps that will be performed.

Pseudocode is usually a mixture of a common written language, like English, with programming constructs, like `IF`, `ELSE`, `FOR`, and `WHILE`.

This is an example of pseudocode that you may write to solve the "Reverse a String" challenge.

```md
GET original_string

SET reversed_string = ""

FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string

DISPLAY reversed_string
```

Note how the steps are outlined in a way that is easy to understand. The words and constructs themselves might vary depending on the standards that you are following.

If you wanted to, you could implement these steps in multiple programming languages following the same logic, since the pseudocode is independent of the programming language.

By this point, you may have already realized that this problem can be solved in many different ways. This isn't the only way to reverse a string.

But remember that choosing the right algorithm is important.

In a previous lecture, you learned about algorithmic complexity and why it is important to choose algorithms that are efficient in terms of time and space.

That's where you will play a vital role as a developer. You will need to choose the most efficient algorithm to solve the challenge.

Thinking through different available algorithms is an important problem-solving skill that you should practice. Take a moment to ask yourself if the solution that you are proposing in your pseudocode is the best one or not.

For example, there are many different algorithms for sorting elements, but some of them are more efficient than others. Bubble sort, for example, is very inefficient for sorting large lists, while Quick Sort is usually more efficient.

For our "Reverse a String" challenge, we could use either one of these approaches, assuming that we are planning to implement our algorithm in Python:

* Using the extended slice syntax `[::-1]` to get a new reversed string.
    
* Looping over the characters from left to right and adding the new character to the beginning of the new string.
    
* Calling the `reversed()` function to get an iterator with all the characters in reverse order, and then the `““.join()` method to concatenate them back into a string.
    

Which one should you use? That's your choice.

Making these decisions based on your knowledge and experience can make a huge difference in the final performance of your application. Consider different approaches, their efficiency, implications, and implementation.

Ask yourself:

* "How will I approach this problem?"
    
* "What data structures will I use?"
    
* "Are the data structures that I chose the most efficient ones for the problem at hand?"
    
* "Am I covering all possible edge cases?"
    

Edge cases are specific, valid inputs or conditions that occur at the boundaries of what an algorithm should handle.

For example, in the "Reverse a String" challenge, an edge case would be taking an empty string as input. Are you handling this correctly? If not, consider the best way to handle this edge case and add it to your pseudocode.

Then, once you are happy with your plan, you can move on to the implementation phase. At this phase, you will implement your algorithm in a programming language.

When structuring your program, you should write modular code that is easy to read and understand.

Use the tools of the programming language based on your current knowledge. Some programming languages include built-in solutions for common problems and tasks. Use them if possible.

To be consistent, follow the best practices of the programming language of your choice.

Test your code as you write it and make sure that you are handling edge cases appropriately.

Once your solution is implemented, check if it works correctly for all the examples and potentially refactor your code to make it clearer or simpler.

Going back to your solution is very important. Development is not necessarily a linear, step-by-step process. You can always go back to your code and use your critical thinking skills to improve it.

These are some common problem-solving techniques that you can follow to approach algorithmic challenges. If you practice consistently, you will gradually develop your problem-solving skills.

# --questions--

## --text--

Which of the following is the most important first step when approaching any problem-solving challenge?

## --answers--

Understand the problem statement, inputs, and constraints.

---

Search for existing solutions online.

### --feedback--

What should you do before you even think about solutions?

---

Immediately start writing code.

### --feedback--

What should you do before you even think about solutions?

---

Guess a solution and then try to make it work.

### --feedback--

What should you do before you even think about solutions?

## --video-solution--

1

## --text--

What is the main purpose of writing pseudocode when solving an algorithmic challenge?

## --answers--

To write the final, executable version of the code.

### --feedback--

Think about what pseudocode helps you do before you start writing code.

---

To test the algorithm's performance and find bugs.

### --feedback--

Think about what pseudocode helps you do before you start writing code.

---

To outline the algorithm's logic in a human-readable, language-agnostic way.

---

To automatically generate the actual code for the solution.

### --feedback--

Think about what pseudocode helps you do before you start writing code.

## --video-solution--

3

## --text--

Before writing the final code for an algorithmic challenge, why is it important to consider edge cases?

## --answers--

Edge cases are always the easiest parts of the problem to solve.

### --feedback--

Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.

---

They help ensure the algorithm works correctly for all valid inputs.

---

They are only relevant for very simple problems.

### --feedback--

Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.

---

They make the code shorter.

### --feedback--

Think about what kind of inputs might cause unexpected behavior if they are not specifically considered, even if they are valid.

## --video-solution--

2

