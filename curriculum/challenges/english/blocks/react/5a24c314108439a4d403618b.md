---
id: 5a24c314108439a4d403618b
title: Give Sibling Elements a Unique Key Attribute
challengeType: 6
forumTopicId: 301394
dashedName: give-sibling-elements-a-unique-key-attribute
---

# --description--

The last challenge showed how the `map` method is used to dynamically render a number of elements based on user input. However, there was an important piece missing from that example. When you create an array of elements, each one needs a `key` attribute set to a unique value. React uses these keys to keep track of which items are added, changed, or removed. This helps make the re-rendering process more efficient when the list is modified in any way.

**Note:** Keys only need to be unique between sibling elements, they don't need to be globally unique in your application.

### Warning vs. Error

It is important to note that if you forget to provide a `key` prop, React will not throw a fatal error that stops your app. Instead, you will see a warning in the console. While your UI might still render correctly in simple cases, missing keys can lead to hard-to-debug issues with component state and focus management.

### Index as Key Anti-pattern

You might be tempted to use the array index as the key, like this:

```jsx
// Bad Practice: Using index as key
{todos.map((todo, index) => (
  <li key={index}>{todo.text}</li>
))}
```

This is generally considered an anti-pattern. If your list can be reordered, sorted, or filtered, using the index as a key can cause React to incorrectly identify elements. This can lead to performance issues and subtle bugs where the state of one component "leaks" into another.

**Note:** For this specific challenge, the `frontEndFrameworks` array is static (it will not change order). In this case, using the index as a key is acceptable and is the expected solution. However, in most real-world applications with dynamic data, you should use a unique ID.

### Unique IDs & Reconciliation

The best practice is to use a stable, unique identifier for each item, such as an ID from your database or a UUID.

```jsx
// Best Practice: Using unique ID as key
{todos.map((todo) => (
  <li key={todo.id}>{todo.text}</li>
))}
```

**Why is this important?**

React uses a process called **Reconciliation** to update the DOM. When a list changes, React compares the new list with the old one. Keys act as stable identities for your elements. If an item's key stays the same, React knows it's the same component and can just update it. If the key changes (or if you use indices and the order changes), React might destroy and recreate the component unnecessarily, or worse, update the wrong component with the wrong state.

# --instructions--

The code editor has an array with some front end frameworks and a stateless functional component named `Frameworks()`. `Frameworks()` needs to map the array to an unordered list, much like in the last challenge. Finish writing the `map` callback to return an `li` element for each framework in the `frontEndFrameworks` array. This time, make sure to give each `li` a `key` attribute, set to a unique value. The `li` elements should also contain text from `frontEndFrameworks`.

Normally, you want to make the key something that uniquely identifies the element being rendered. As a last resort the array index may be used, but typically you should try to use a unique identification.

# --hints--

The `Frameworks` component should exist and render to the page.

```js
assert(
  Enzyme.mount(React.createElement(Frameworks)).find('Frameworks').length === 1
);
```

`Frameworks` should render an `h1` element.

```js
assert(Enzyme.mount(React.createElement(Frameworks)).find('h1').length === 1);
```

`Frameworks` should render a `ul` element.

```js
assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').length === 1);
```

The `ul` tag should render 6 child `li` elements.

```js
assert(
  Enzyme.mount(React.createElement(Frameworks)).find('ul').children().length ===
    6 &&
    Enzyme.mount(React.createElement(Frameworks))
      .find('ul')
      .childAt(0)
      .name() === 'li' &&
    Enzyme.mount(React.createElement(Frameworks)).find('li').length === 6
);
```

Each list item element should have a unique `key` attribute.

```js
assert(
  (() => {
    const ul = Enzyme.mount(React.createElement(Frameworks)).find('ul');
    const keys = new Set([
      ul.childAt(0).key(),
      ul.childAt(1).key(),
      ul.childAt(2).key(),
      ul.childAt(3).key(),
      ul.childAt(4).key(),
      ul.childAt(5).key()
    ]);
    return keys.size === 6;
  })()
);
```

Each list item element should contain text from `frontEndFrameworks`.

```js
assert(
  (() => {
    const li = Enzyme.mount(React.createElement(Frameworks))
      .find('ul')
      .children();
    return [...Array(5)].every((_, i) =>
      frontEndFrameworks.includes(li.at(i).text())
    );
  })()
);
```

# --seed--

## --after-user-code--

```jsx
ReactDOM.render(<Frameworks />, document.getElementById('root'))
```

## --seed-contents--

```jsx
const frontEndFrameworks = [
  'React',
  'Angular',
  'Ember',
  'Knockout',
  'Backbone',
  'Vue'
];

function Frameworks() {
  const renderFrameworks = null; // Change this line
  return (
    <div>
      <h1>Popular Front End JavaScript Frameworks</h1>
      <ul>
        {renderFrameworks}
      </ul>
    </div>
  );
};
```

# --solutions--

```jsx
const frontEndFrameworks = [
  'React',
  'Angular',
  'Ember',
  'Knockout',
  'Backbone',
  'Vue'
];

function Frameworks() {
  const renderFrameworks = frontEndFrameworks.map((fw, i) => <li key={i}>{fw}</li>);
  return (
    <div>
      <h1>Popular Front End JavaScript Frameworks</h1>
      <ul>
        {renderFrameworks}
      </ul>
    </div>
  );
};
```
