---
id: 68760c4c2648e7832c5eef16
title: Step 14
challengeType: 20
dashedName: step-14
---

# --description--

After the loop that finds the nearest unvisited node, you need to check whether a valid node was actually found.

If no such node exists, that means the remaining nodes are unreachable from the start node, and the algorithm should stop early.

On the same level as the nested `for` loop, add an `if` statement that checks if `current == -1` and breaks out of the loop if true.

# --hints--

You should have an `if` statement that checks if `current` is still `-1` after the inner `for` loop.

```js
({
    test: () => {
      runPython(`
      cond = _Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].find_ifs()[0].find_conditions()[0]
      assert cond.is_equivalent("current == -1") or cond.is_equivalent("-1 == current")
      `);
    }
});
```

You should use a `break` statement to break out of the loop.

```js
({
    test: () => {
      runPython(`
      assert _Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].has_stmt("break")
      `);
    }
});
```

# --seed--

## --seed-contents--

```py
INF = float('inf')
adj_matrix = [
    [0, 5, 3, INF, 11, INF],
    [5, 0, 1, INF, INF, 2],
    [3, 1, 0, 1, 5, INF],
    [INF, INF, 1, 0, 9, 3],
    [11, INF, 5, 9, 0, INF],
    [INF, 2, INF, 3, INF, 0],
]

def shortest_path(matrix, start_node, target_node=None):
    n = len(matrix)
    distances = [INF] * n
    distances[start_node] = 0
    paths = [[node_no] for node_no in range(n)]
    visited = [False] * n

    for _ in range(n):
        min_distance = INF  
        current = -1  
        for node_no in range(n):  
            if not visited[node_no] and distances[node_no] < min_distance:  
                min_distance = distances[node_no]  
                current = node_no

--fcc-editable-region--

--fcc-editable-region--
```
