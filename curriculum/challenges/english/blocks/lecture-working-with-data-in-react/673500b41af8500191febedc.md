---
id: 673500b41af8500191febedc
title: How Do You Render Lists in React?
challengeType: 19
dashedName: how-do-you-render-lists-in-react
---

# --description--

Rendering lists is a fundamental task in React web apps, and is used for displaying data to users. In React, the `map` method is used to transform an array of data into an array of JSX elements that can be rendered in the UI.

Here is an example of a component called `FruitList` that displays a list of fruits:

```jsx
function FruitList() {
  const fruits = ['Apple', 'Banana', 'Cherry', 'Date'];
  return (
    <ul>
      {fruits.map(fruit => <li>{fruit}</li>)}
    </ul>
  );
}
```

In this example, the `map` function iterates over each item in the `fruits` array. For each fruit, it creates a new `li` element containing the fruit's name. The newly created array of `li` elements is then displayed inside the `ul` parent tags.

However, when rendering lists in React, it is important not to forget the `key` prop for each element in the list. The key must always be unique and it helps React identify which items have changed, been added, or been removed, which is essential for efficient rendering and updating the list. 

Let's modify our example to include keys:

```jsx
function FruitList() {
  const fruits = ["Apple", "Banana", "Cherry", "Date"];
  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={`${fruit}-${index}`}>{fruit}</li>
      ))}
    </ul>
  );
}
```

In this refactored example, we are creating a unique key for each list item by concatenating the fruit name with its index. This ensures that each list item has a distinct key, which helps React efficiently manage and update the list when items are added, removed, or reordered.

React also allows you to render more complex structures. For instance, you might have an array of objects representing users, each with multiple properties that you want to display:

```jsx
function UserList() {
  const users = [
    { id: "user-001-employee", name: "Alice", email: "alice@example.com" },
    { id: "user-002-employee", name: "Bob", email: "bob@example.com" },
    { id: "user-003-employee", name: "John", email: "john@example.com" },
  ];
  return (
    <div>
      {users.map((user) => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
}
```

In this example, we're creating a more complex JSX structure for each user, displaying both their name and email address. We're using the user's `id` as the `key`, which is a good practice.

# what happens when you forget the key
If you omit the `key` prop on list items, React logs a warning (not an error), and while the UI may still render, React’s reconciliation becomes unreliable—without stable keys, React may reuse DOM nodes incorrectly when items are reordered or updated, causing incorrect display, mixed-up component state (like input values or focus), and subtle, hard-to-debug bugs. In short, forgetting or misusing keys won’t stop your build, but it significantly harms the correctness and maintainability of your UI.

```
function List() {
  const items = ['Apple', 'Banana', 'Cherry'];
  return (
    <ul>
      {items.map(item => (
        <li>{item}</li>  // ⚠️ Missing key prop
      ))}
    </ul>
  );
}
```

#  Is using array index as key is problematic
```
{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}
```

While this works, it is risky and discouraged in most cases.

Why this is problematic:

- Lack of stability:
    When items are reordered, inserted, or removed, array indices shift. This causes keys to point to the wrong items, breaking React’s assumptions about identity.

- State mismatch:
    If list items contain stateful components (e.g., inputs), React may mix up their state because it thinks an item with the same index-key is the “same” component—even when it's not.

- Performance inefficiency:
    Unstable keys force React to re-render or recreate DOM nodes unnecessarily, reducing the benefits of efficient reconciliation.

- Future fragility:
    Even if a list is “static” today, future features (sorting, filtering, dynamic inserts) may break behavior—index keys make refactoring painful.

- Docs & community warnings:
    React documentation, linters, and style guides all caution against index keys except in rare, controlled cases.

- React says index keys are safe only when:
    The list is truly static (no reordering, filtering, insertion, or removal), and the data does not have any stable unique identifier.

# How to get/create a unique id when one is not readily available

If your data items don’t already have unique IDs, here are a few strategies to generate or maintain stable keys:

Using IDs from your data

Best approach: if each item has a unique, stable identifier (e.g., from the backend, database), use that:

```
{items.map(item => (
  <li key={item.id}>{item.name}</li>
))}
```


This ensures key doesn’t change across renders (unless the data itself changes) and allows React to track items correctly. 

Generating IDs up-front (once) if your data doesn’t come with IDs, you can generate them before using them in React — e.g., when you fetch or construct your data, add a UUID or nanoid field. 
Example using nanoid:

```
import { nanoid } from 'nanoid';

const rawItems = [{ name: 'A' }, { name: 'B' }, …];
const itemsWithId = rawItems.map(item => ({ ...item, id: nanoid() }));
```

Then use item.id as the React key.

React 18 introduced a built-in hook useId() that generates unique IDs that are stable across the component lifecycle. 

However, useId() is more intended for associating IDs for HTML accessibility (like linking form inputs to labels). It’s not a drop-in replacement for list keys in all situations, especially for dynamic lists, unless used carefully.
Keys are not just unique, but they must also be stable: they should not change between renders for the same item. If a key changes, React treats it as a different component, unmounting the old one and mounting a new one, losing any state.

This helps avoid regenerating keys on every render, which would defeat the purpose.

In conclusion, rendering lists in React involves converting arrays of data into JSX elements, typically using the `map` function.

# --questions--

## --text--

What is the primary purpose of using the `key` prop when rendering lists in React?

## --answers--

To style list items.

### --feedback--

Think about what we said regarding React's rendering optimization.

---

To help React identify changes in the list efficiently.

---

To sort the list items.

### --feedback--

Think about what we said regarding React's rendering optimization.

---

To filter the list items.

### --feedback--

Think about what we said regarding React's rendering optimization.

## --video-solution--

2

## --text--

Which JavaScript method is typically used to transform an array of data into an array of JSX elements in React?

## --answers--

`forEach()`

### --feedback--

Recall the method we consistently used in our examples for creating JSX elements from array items.

---

`reduce()`

### --feedback--

Recall the method we consistently used in our examples for creating JSX elements from array items.

---

`map()`

---

`filter()`

### --feedback--

Recall the method we consistently used in our examples for creating JSX elements from array items.

## --video-solution--

3

## --text--

When rendering a list of items that have unique IDs, what is considered the best practice for the `key` prop?

## --answers--

Use the index of the item in the array.

### --feedback--

Remember what we said about using stable and unique identifiers for keys.

---

Use a random number.

### --feedback--

Remember what we said about using stable and unique identifiers for keys.

---

Use the item's unique ID.

---

Use the item's name or title.

### --feedback--

Remember what we said about using stable and unique identifiers for keys.

## --video-solution--

3
