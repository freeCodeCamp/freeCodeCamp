---
id: 6930c6ffe3de7934afe5e785
title: Step 5
challengeType: 0
dashedName: step-5
---

# --description--

Now you'll build the main `simulateFestival` function that orchestrates the entire simulation.

Create a function called `simulateFestival` that takes parameters `baseGates` and `options` (default to an empty object).

Use the nullish coalescing operator (`??`) to extract `backups` and `capUpdates` from options with default values. Find the maximum queue length across all gates using `.reduce()` to determine how many ticks the simulation needs to run.

Clone each gate using `.map()` and add runtime tracking fields: `pendingAttendees`, `throughput`, `throughputPerTick`, `peakQueue`, `reroutedOut`, and `reroutedIn`. Use `.slice()` to copy the queue array.

Use a `while` loop that continues as long as `hasWork()` returns true. In each iteration, use `.forEach()` to apply capacity updates to all gates, then process each gate. Increment the tick counter after each iteration.

Return an object containing the final `gates` array and the total number of ticks.

# --hints--

You should declare a function called `simulateFestival`.

```js
assert.isFunction(simulateFestival);
```

Your `simulateFestival` function should have two parameters.

```js
assert.strictEqual(simulateFestival.length, 2);
```

Your function should use the nullish coalescing operator (`??`) to provide default values for options.

```js
assert.match(code, /\?\?/);
```

Your function should use `.reduce()` to calculate the maximum queue length.

```js
assert.match(code, /\.reduce\s*\(/);
```

Your function should use `.map()` to clone and extend the gates.

```js
assert.match(code, /\.map\s*\(/);
```

Your function should use `.slice()` to copy the queue array without mutating the original.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const originalQueue = testGates[0].queue;
simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.strictEqual(testGates[0].queue, originalQueue);
```

Your cloned gates should have a `pendingAttendees` property initialized to 0.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.strictEqual(result.gates[0].pendingAttendees, 0);
```

Your cloned gates should have a `throughput` property that tracks total served attendees.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.strictEqual(result.gates[0].throughput, 5);
```

Your cloned gates should have a `throughputPerTick` property initialized as an empty array.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.isArray(result.gates[0].throughputPerTick);
```

Your cloned gates should have `peakQueue`, `reroutedOut`, and `reroutedIn` properties.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.property(result.gates[0], 'peakQueue');
assert.property(result.gates[0], 'reroutedOut');
assert.property(result.gates[0], 'reroutedIn');
```

Your function should use a `while` loop to process ticks.

```js
assert.match(code, /while\s*\(/);
```

Your function should use `.forEach()` to iterate over gates during processing.

```js
assert.match(code, /\.forEach\s*\(/);
```

Your function should return an object with both `gates` and `totalTicks` properties.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.isObject(result);
assert.property(result, 'gates');
assert.property(result, 'totalTicks');
```

The returned `gates` should be an array and `totalTicks` should be a number.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.isArray(result.gates);
assert.isNumber(result.totalTicks);
```

Your function should process all attendees until queues are empty. A gate with 5 total arrivals and capacity 5 should serve all 5 attendees.

```js
const testGates = [{ id: 'A', capacity: 5, queue: [3, 2] }];
const result = simulateFestival(testGates, { backups: [], capUpdates: {} });
assert.strictEqual(result.gates[0].throughput, 5);
assert.strictEqual(result.gates[0].pendingAttendees, 0);
```

# --seed--

## --seed-contents--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

function processGate(gate, gates, backups, tick) {
  gate.pendingAttendees += gate.queue[tick] ?? 0;
  if (gate.pendingAttendees > gate.peakQueue)
    gate.peakQueue = gate.pendingAttendees;
  let served = Math.min(gate.capacity, gate.pendingAttendees);
  gate.pendingAttendees -= served;
  gate.throughput += served;
  gate.throughputPerTick.push(served);
  handleCongestion(gate, gates, backups, tick);
}

function hasWork(gates, tick, maxTick) {
  return tick < maxTick || gates.some(gate => gate.pendingAttendees > 0);
}

function applyCapacityUpdate(gate, tick, capacityUpdates) {
  const updates = capacityUpdates[gate.id];
  if (updates?.[tick] != null) gate.capacity = updates[tick];
}

function nextTick(tick) {
  return tick + 1;
}

--fcc-editable-region--

--fcc-editable-region--
```

# --solutions--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

function processGate(gate, gates, backups, tick) {
  gate.pendingAttendees += gate.queue[tick] ?? 0;
  if (gate.pendingAttendees > gate.peakQueue)
    gate.peakQueue = gate.pendingAttendees;
  let served = Math.min(gate.capacity, gate.pendingAttendees);
  gate.pendingAttendees -= served;
  gate.throughput += served;
  gate.throughputPerTick.push(served);
  handleCongestion(gate, gates, backups, tick);
}

function hasWork(gates, tick, maxTick) {
  return tick < maxTick || gates.some(gate => gate.pendingAttendees > 0);
}

function applyCapacityUpdate(gate, tick, capacityUpdates) {
  const updates = capacityUpdates[gate.id];
  if (updates?.[tick] != null) gate.capacity = updates[tick];
}

function nextTick(tick) {
  return tick + 1;
}

function simulateFestival(baseGates, options = {}) {
  const backups = options.backups ?? {};
  const capacityUpdates = options.capUpdates ?? {};
  const maxTick = baseGates.reduce(
    (max, gate) => Math.max(max, gate.queue.length),
    0
  );
  const gates = baseGates.map(gate => ({
    id: gate.id,
    capacity: gate.capacity,
    queue: gate.queue.slice(),
    pendingAttendees: 0,
    throughput: 0,
    throughputPerTick: [],
    peakQueue: 0,
    reroutedOut: 0,
    reroutedIn: 0
  }));
  let tick = 0;
  while (hasWork(gates, tick, maxTick)) {
    gates.forEach(gate => applyCapacityUpdate(gate, tick, capacityUpdates));
    gates.forEach(gate => processGate(gate, gates, backups, tick));
    tick = nextTick(tick);
  }
  return { gates, totalTicks: tick };
}
```
