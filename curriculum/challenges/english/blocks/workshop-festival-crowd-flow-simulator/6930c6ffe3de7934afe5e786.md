---
id: 6930c6ffe3de7934afe5e786
title: Step 6
challengeType: 0
dashedName: step-6
---

# --description--

Finally, you'll create test runner functions to display simulation results.

Create a `summarize` function that takes one parameter (the result from `simulateFestival`). Extract `gates` and `totalTicks` from the result, then call `measureThroughput` and `measureCongestion` with the gates. Use `console.log()` to display the tick count, throughput data, and congestion data.

Create a `runTests` function with no parameters. This function should run both morning and evening scenarios using `simulateFestival` and display their results by calling `summarize`.

You can call `simulateFestival` directly inside the `summarize` function call, passing the result as an argument like `summarize(simulateFestival(gates, options))`.

# --hints--

You should declare a function called `summarize`.

```js
assert.isFunction(summarize);
```

Your `summarize` function should have one parameter.

```js
assert.strictEqual(summarize.length, 1);
```

Your `summarize` function should call `measureThroughput` with the gates.

```js
assert.match(code, /measureThroughput\s*\(\s*gates\s*\)/);
```

Your `summarize` function should call `measureCongestion` with the gates.

```js
assert.match(code, /measureCongestion\s*\(\s*gates\s*\)/);
```

Your `summarize` function should use `console.log()` to display output.

```js
assert.match(code, /console\.log\s*\(/);
```

You should declare a function called `runTests`.

```js
assert.isFunction(runTests);
```

Your `runTests` function should have no parameters.

```js
assert.strictEqual(runTests.length, 0);
```

Your `runTests` function should call `simulateFestival` with `morningGates`.

```js
assert.match(code, /simulateFestival\s*\(\s*morningGates/);
```

Your `runTests` function should call `simulateFestival` with `eveningGates`.

```js
assert.match(code, /simulateFestival\s*\(\s*eveningGates/);
```

Your `runTests` function should call `summarize` at least twice.

```js
const matches = code.match(/summarize\s*\(/g);
assert.isAtLeast(matches?.length || 0, 2);
```

# --seed--

## --seed-contents--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function measureCongestion(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    peakQueue: gateData.peakQueue,
    reroutedOut: gateData.reroutedOut,
    reroutedIn: gateData.reroutedIn
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

function processGate(gate, gates, backups, tick) {
  gate.pendingAttendees += gate.queue[tick] ?? 0;
  if (gate.pendingAttendees > gate.peakQueue)
    gate.peakQueue = gate.pendingAttendees;
  let served = Math.min(gate.capacity, gate.pendingAttendees);
  gate.pendingAttendees -= served;
  gate.throughput += served;
  gate.throughputPerTick.push(served);
  handleCongestion(gate, gates, backups, tick);
}

function hasWork(gates, tick, maxTick) {
  return tick < maxTick || gates.some(gate => gate.pendingAttendees > 0);
}

function applyCapacityUpdate(gate, tick, capacityUpdates) {
  const updates = capacityUpdates[gate.id];
  if (updates?.[tick] != null) gate.capacity = updates[tick];
}

function nextTick(tick) {
  return tick + 1;
}

function simulateFestival(baseGates, options = {}) {
  const backups = options.backups ?? {};
  const capacityUpdates = options.capUpdates ?? {};
  const maxTick = baseGates.reduce(
    (max, gate) => Math.max(max, gate.queue.length),
    0
  );
  const gates = baseGates.map(gate => ({
    id: gate.id,
    capacity: gate.capacity,
    queue: gate.queue.slice(),
    pendingAttendees: 0,
    throughput: 0,
    throughputPerTick: [],
    peakQueue: 0,
    reroutedOut: 0,
    reroutedIn: 0
  }));
  let tick = 0;
  while (hasWork(gates, tick, maxTick)) {
    gates.forEach(gate => applyCapacityUpdate(gate, tick, capacityUpdates));
    gates.forEach(gate => processGate(gate, gates, backups, tick));
    tick = nextTick(tick);
  }
  return { gates, totalTicks: tick };
}

--fcc-editable-region--

--fcc-editable-region--
```

# --solutions--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function measureCongestion(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    peakQueue: gateData.peakQueue,
    reroutedOut: gateData.reroutedOut,
    reroutedIn: gateData.reroutedIn
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

function processGate(gate, gates, backups, tick) {
  gate.pendingAttendees += gate.queue[tick] ?? 0;
  if (gate.pendingAttendees > gate.peakQueue)
    gate.peakQueue = gate.pendingAttendees;
  let served = Math.min(gate.capacity, gate.pendingAttendees);
  gate.pendingAttendees -= served;
  gate.throughput += served;
  gate.throughputPerTick.push(served);
  handleCongestion(gate, gates, backups, tick);
}

function hasWork(gates, tick, maxTick) {
  return tick < maxTick || gates.some(gate => gate.pendingAttendees > 0);
}

function applyCapacityUpdate(gate, tick, capacityUpdates) {
  const updates = capacityUpdates[gate.id];
  if (updates?.[tick] != null) gate.capacity = updates[tick];
}

function nextTick(tick) {
  return tick + 1;
}

function simulateFestival(baseGates, options = {}) {
  const backups = options.backups ?? {};
  const capacityUpdates = options.capUpdates ?? {};
  const maxTick = baseGates.reduce(
    (max, gate) => Math.max(max, gate.queue.length),
    0
  );
  const gates = baseGates.map(gate => ({
    id: gate.id,
    capacity: gate.capacity,
    queue: gate.queue.slice(),
    pendingAttendees: 0,
    throughput: 0,
    throughputPerTick: [],
    peakQueue: 0,
    reroutedOut: 0,
    reroutedIn: 0
  }));
  let tick = 0;
  while (hasWork(gates, tick, maxTick)) {
    gates.forEach(gate => applyCapacityUpdate(gate, tick, capacityUpdates));
    gates.forEach(gate => processGate(gate, gates, backups, tick));
    tick = nextTick(tick);
  }
  return { gates, totalTicks: tick };
}

function summarize(result) {
  const { gates, totalTicks } = result;
  const throughput = measureThroughput(gates);
  const congestion = measureCongestion(gates);
  console.log('=== Summary ===');
  console.log(`ticks: ${totalTicks}`);
  console.log('Throughput:');
  throughput.forEach(d =>
    console.log(
      ` ${d.id}: total=${d.totalServed}, perTick=[${d.perTick.join(',')}]`
    )
  );
  console.log('Congestion:');
  congestion.forEach(d =>
    console.log(
      ` ${d.id}: peak=${d.peakQueue}, out=${d.reroutedOut}, in=${d.reroutedIn}`
    )
  );
  console.log(
    'Queues empty:',
    gates.every(gate => gate.pendingAttendees === 0) ? 'YES' : 'NO'
  );
}

function runTests() {
  console.log('== Morning ==');
  summarize(
    simulateFestival(morningGates, {
      backups: morningBackups,
      capUpdates: morningCapacityUpdates,
      congestionThreshold: 7
    })
  );
  console.log('== Evening ==');
  summarize(
    simulateFestival(eveningGates, {
      backups: eveningBackups,
      capUpdates: eveningCapacityUpdates,
      congestionThreshold: 5
    })
  );
}
```
