---
id: 6930c6ffe3de7934afe5e784
title: Step 4
challengeType: 0
dashedName: step-4
---

# --description--

Now you'll build the `processGate` function, which handles the core logic of processing attendees at each gate during a single tick.

Create a function called `processGate` that takes four parameters: `gate`, `gates`, `backups`, and `tick`.

When a gate processes attendees, you need to add any new arrivals from the queue to `pendingAttendees`. Since `queue[tick]` might be undefined, use the nullish coalescing operator (`??`) to default to 0. Next, update `peakQueue` if the current `pendingAttendees` is higher than the previous peak. Then calculate how many attendees can be served using `Math.min()`. Finally, call `handleCongestion` to check if the gate needs to reroute overflow attendees to backup gates.

# --hints--

You should declare a function called `processGate`.

```js
assert.isFunction(processGate);
```

Your `processGate` function should have four parameters.

```js
assert.strictEqual(processGate.length, 4);
```

Your function should use the nullish coalescing operator (`??`) when accessing the queue array.

```js
assert.match(code, /\?\?/);
```

Your function should add arrivals to `pendingAttendees`. When you process tick 0 with a gate that has 3 arrivals in `queue[0]`, `pendingAttendees` should increase by 3.

```js
const gate = {
  id: 'A',
  capacity: 5,
  queue: [3, 2, 1],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 0);
assert.strictEqual(gate.pendingAttendees, 0);
```

Your function should handle queue indices that don't exist by treating them as 0. When you process tick 5 with a gate that only has a 3-element queue, no error should occur and `pendingAttendees` should remain unchanged (after serving).

```js
const gate = {
  id: 'A',
  capacity: 10,
  queue: [1, 2, 3],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 5);
assert.strictEqual(gate.pendingAttendees, 0);
```

Your function should update `peakQueue` when `pendingAttendees` exceeds the current peak. When you process a gate with 5 arrivals and capacity 2, `peakQueue` should become 5.

```js
const gate = {
  id: 'A',
  capacity: 2,
  queue: [5, 0],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 0);
assert.strictEqual(gate.peakQueue, 5);
```

Your function should use `Math.min()` to calculate the number served.

```js
assert.match(code, /Math\.min\s*\(/);
```

Your function should serve the minimum of capacity and pending attendees. When a gate has capacity 3 and 5 pending attendees, it should serve 3 and leave 2 pending.

```js
const gate = {
  id: 'A',
  capacity: 3,
  queue: [5, 0],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 0);
assert.strictEqual(gate.throughput, 3);
assert.strictEqual(gate.pendingAttendees, 2);
```

Your function should accumulate `throughput` across multiple ticks. When you process a gate twice that serves 3 attendees each tick, total `throughput` should be 6.

```js
const gate = {
  id: 'A',
  capacity: 5,
  queue: [3, 2],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 0);
processGate(gate, [gate], [], 1);
assert.strictEqual(gate.throughput, 5);
```

Your function should push the number served to the `throughputPerTick` array. After processing tick 0 where 3 attendees were served, `throughputPerTick` should be `[3]`.

```js
const gate = {
  id: 'A',
  capacity: 5,
  queue: [3, 2],
  pendingAttendees: 0,
  throughput: 0,
  throughputPerTick: [],
  peakQueue: 0,
  reroutedOut: 0,
  reroutedIn: 0
};
processGate(gate, [gate], [], 0);
assert.deepStrictEqual(gate.throughputPerTick, [3]);
```

Your function should call `handleCongestion` after processing. This allows overflow attendees to be rerouted to backup gates.

```js
assert.match(code, /handleCongestion\s*\(/);
```

# --seed--

## --seed-contents--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

--fcc-editable-region--

--fcc-editable-region--
```

# --solutions--

```js
const morningGates = [
  { id: 'North', capacity: 5, queue: [8, 3, 4, 10, 1, 0, 2] },
  { id: 'East', capacity: 4, queue: [4, 6, 0, 2, 8, 3, 1] },
  { id: 'West', capacity: 3, queue: [2, 5, 3, 1, 0, 0, 0] },
  { id: 'South', capacity: 2, queue: [5, 2, 3, 7, 2, 1, 0] }
];

const eveningGates = [
  { id: 'North', capacity: 4, queue: [2, 2, 2, 2, 2, 2] },
  { id: 'East', capacity: 3, queue: [1, 1, 1, 5, 0, 0] },
  { id: 'West', capacity: 2, queue: [0, 0, 3, 3, 3, 3] },
  { id: 'South', capacity: 2, queue: [3, 3, 2, 2, 1, 1] },
  { id: 'Southwest', capacity: 2, queue: [2, 2, 3, 4, 0, 0] }
];

const morningBackups = ['East', 'West', 'North', 'South'];
const eveningBackups = ['East', 'West', 'North', 'Southwest', 'South'];

const morningCapacityUpdates = {
  North: { 3: 3, 6: 2 },
  East: { 4: 6 },
  West: { 2: 1 },
  South: { 4: 1 }
};
const eveningCapacityUpdates = {
  North: { 5: 2 },
  East: {},
  West: { 3: 4 },
  South: { 3: 1 },
  Southwest: { 4: 1 }
};

function measureThroughput(gatesList) {
  return gatesList.map(gateData => ({
    id: gateData.id,
    totalServed: gateData.throughput,
    perTick: gateData.throughputPerTick.slice()
  }));
}

function handleCongestion(gate, gates, backups, tick) {
  if (gate.pendingAttendees <= gate.capacity) return;
  const overflow = gate.pendingAttendees - gate.capacity;
  for (const backupGateId of backups) {
    const backupGate = gates.find(g => g.id === backupGateId);
    if (backupGate && backupGate.pendingAttendees <= backupGate.capacity) {
      gate.pendingAttendees -= overflow;
      backupGate.pendingAttendees += overflow;
      gate.reroutedOut += overflow;
      backupGate.reroutedIn += overflow;
      console.log(
        `[T${tick}] reroute ${overflow} from ${gate.id} -> ${backupGate.id}`
      );
      return;
    }
  }
  console.log(
    `[T${tick}] congest at ${gate.id}, q=${gate.pendingAttendees}, all backups over capacity`
  );
}

function processGate(gate, gates, backups, tick) {
  gate.pendingAttendees += gate.queue[tick] ?? 0;
  if (gate.pendingAttendees > gate.peakQueue)
    gate.peakQueue = gate.pendingAttendees;
  let served = Math.min(gate.capacity, gate.pendingAttendees);
  gate.pendingAttendees -= served;
  gate.throughput += served;
  gate.throughputPerTick.push(served);
  handleCongestion(gate, gates, backups, tick);
}
```
