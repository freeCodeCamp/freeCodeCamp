---
id: 688ac1de985053329b4573d3
title: Step 19
challengeType: 20
dashedName: step-19
---

# --description--

Next, assign `current_node.next` to `current_node` in the `while` loop. 

This moves the `current_node` pointer to the next node in the list during each iteration of the loop, allowing you to traverse the linked list until the element is found or the end of the list is reached.

# --hints--

You should assign `current_node.next` to `current_node` inside the `while` loop.

```js
({ test: () => runPython(`
_cond = _Node(_code).find_class("LinkedList").find_function("remove").find_whiles()[0]
assert _cond.is_equivalent("while current_node is not None and current_node.element != element:\\n previous_node = current_node\\n current_node = current_node.next")
`) })
```

# --seed--

## --seed-contents--

```py
class LinkedList:
    class Node:
        def __init__(self, element):
            self.element = element
            self.next = None
            
    def __init__(self):
        self.length = 0
        self.head = None

    def is_empty(self):
        return self.length == 0
    
    def add(self, element):
        node = self.Node(element)
        if self.is_empty():
            self.head = node
        else:
            current_node = self.head
            while current_node.next is not None:
                current_node = current_node.next
        self.length += 1

    def remove(self, element):
        previous_node = None
        current_node = self.head
--fcc-editable-region--
        while current_node is not None and current_node.element != element:
            previous_node = current_node
--fcc-editable-region--

my_list = LinkedList()
print(my_list.is_empty())

my_list.add(1)
my_list.add(2)
print(my_list.is_empty())
print(my_list.length)
```
