---
id: 68e5293bd00d2fe134f58982
title: Step 6
challengeType: 20
dashedName: step-6
---

# --description--

Abstract methods are methods that must be implemented by any class that inherits from the abstract base class. They serve as a contract, ensuring that all discount strategies will have certain required methods.

Inside your `DiscountStrategy` class, define a method named `is_applicable`. Use the `@abstractmethod` decorator above the method definition. The method should have the following parameters: `self`, `product`, and `user_tier`. Use the `pass` statement in the method body.

Add type hints to make the method signature clear: `product` should be of type `Product`, `user_tier` should be of type `str`, and the method should return a `bool`.

# --hints--

Your `DiscountStrategy` class should have a method named `is_applicable`.

```js

```

Your `is_applicable` method should have the `@abstractmethod` decorator.

```js

```

Your `is_applicable` method should have parameters `self`, `product: Product`, and `user_tier: str`.

```js

```

Your `is_applicable` method should have a return type hint of `-> bool`.

```js

```

# --seed--

## --seed-contents--

```py
from abc import ABC, abstractmethod

class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def __str__(self):
        return f'{self.name} - ${self.price}'

class DiscountStrategy(ABC):
--fcc-editable-region--
    pass
--fcc-editable-region--
product = Product("Wireless Mouse", 50.0)
print(product)
```
