---
id: a5c3d2e1f4b6a9c7d8e9f0a1
title: Lab - Signal Pattern Detector
challengeType: 27
dashedName: lab-signal-pattern-detector
---

# Lab - Signal Pattern Detector

--description--

In this lab, you will scan binary signal sequences for motifs, mirror patterns, and missing frames. You'll implement functions to analyze patterns within sequences of 0s and 1s, detecting repeating elements, symmetries, and gaps in expected binary patterns.

**Objective:** Fulfill the user stories below and get all the tests to pass to complete the lab.

**User Stories:**

1. You should accept an array of signal sequences (each sequence is an array of 0s and 1s).
2. You should implement `findMotif(sequence, motifLength)` using nested loops with early exit flags.
3. You should implement `detectMirror(sequence)` that compares mirrored indices and reports mismatches.
4. You should implement `findMissingFrames(sequence)` that logs gaps in expected binary patterns.
5. You should aggregate results into `{ motifPositions, mirrorsBroken, missingFrames }` for each sequence.

--hints--

You should have a function named `analyzeSignalSequence`.

```javascript
if (typeof analyzeSignalSequence !== 'function') {
  throw new Error('analyzeSignalSequence should be a function');
}
```

Your `analyzeSignalSequence` function should accept an array of sequences.

```javascript
const result = analyzeSignalSequence([[0, 1, 0, 1]]);
assert(Array.isArray(result), 'Should return an array');
```

The function should implement `findMotif` helper using nested loops with early exit.

```javascript
const mockSequence = [1, 0, 1, 0, 1];
const positions = findMotif(mockSequence, 2);
assert(Array.isArray(positions), 'findMotif should return an array');
```

The function should implement `detectMirror` to find mismatches in mirrored indices.

```javascript
const sequence = [1, 0, 1, 0, 1];
const mirrorIssues = detectMirror(sequence);
assert(Array.isArray(mirrorIssues), 'detectMirror should return an array');
```

The function should implement `findMissingFrames` to identify gaps.

```javascript
const sequence = [0, 1, 0, 1, 1, 1, 0];
const gaps = findMissingFrames(sequence);
assert(Array.isArray(gaps), 'findMissingFrames should return an array');
```

The function should aggregate results into objects with required properties.

```javascript
const result = analyzeSignalSequence([[0, 1, 0, 1]]);
assert(result[0].hasOwnProperty('motifPositions'), 'Result should include motifPositions');
assert(result[0].hasOwnProperty('mirrorsBroken'), 'Result should include mirrorsBroken');
assert(result[0].hasOwnProperty('missingFrames'), 'Result should include missingFrames');
```

--seed--

--seed-contents--

// Implement the Signal Pattern Detector
// Your code here

--solutions--

function findMotif(sequence, motifLength) {
  const positions = [];
  let found = false;
  
  for (let i = 0; i <= sequence.length - motifLength && !found; i++) {
    const motif = sequence.slice(i, i + motifLength);
    for (let j = i + motifLength; j <= sequence.length - motifLength; j++) {
      const current = sequence.slice(j, j + motifLength);
      if (JSON.stringify(motif) === JSON.stringify(current)) {
        positions.push(i, j);
        found = true;
        break;
      }
    }
  }
  
  return positions;
}

function detectMirror(sequence) {
  const mismatches = [];
  const len = sequence.length;
  
  for (let i = 0; i < Math.floor(len / 2); i++) {
    if (sequence[i] !== sequence[len - 1 - i]) {
      mismatches.push({ index: i, opposite: len - 1 - i });
    }
  }
  
  return mismatches;
}

function findMissingFrames(sequence) {
  const gaps = [];
  
  for (let i = 0; i < sequence.length - 1; i++) {
    if (sequence[i] === 1 && sequence[i + 1] === 1) {
      gaps.push(i);
    }
  }
  
  return gaps;
}

function analyzeSignalSequence(sequences) {
  return sequences.map(sequence => ({
    motifPositions: findMotif(sequence, 2),
    mirrorsBroken: detectMirror(sequence),
    missingFrames: findMissingFrames(sequence)
  }));
}
