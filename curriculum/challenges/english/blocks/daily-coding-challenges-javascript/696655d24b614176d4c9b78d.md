---
id: 696655d24b614176d4c9b78d
title: "Challenge 170: Odd or Even Day"
challengeType: 28
dashedName: challenge-170
---

# --description--

Given a timestamp (number of milliseconds since the Unix epoch), return:

- `"odd"` if the day of the month for that timestamp is odd.
- `"even"` if the day of the month for that timestamp is even.

For example, given `1769472000000`, a timestamp for January 27th, 2026, return `"odd"` because the day number (`27`) is an odd number.

Note: The timestamp is in milliseconds and you should use the date in the UTC timezone, not in your local time.

# --hints--

`oddOrEvenDay(1769472000000)` should return `"odd"`.

```js
assert.equal(oddOrEvenDay(1769472000000), "odd");
```

`oddOrEvenDay(1769444440000)` should return `"even"`.

```js
assert.equal(oddOrEvenDay(1769444440000), "even");
```

`oddOrEvenDay(6739456780000)` should return `"odd"`.

```js
assert.equal(oddOrEvenDay(6739456780000), "odd");
```

`oddOrEvenDay(1)` should return `"odd"`.

```js
assert.equal(oddOrEvenDay(1), "odd");
```

`oddOrEvenDay(86400000)` should return `"even"`.

```js
assert.equal(oddOrEvenDay(86400000), "even");
```

# --seed--

## --seed-contents--

```js
function oddOrEvenDay(timestamp) {

  return timestamp;
}
```

# --solutions--

```js
function oddOrEvenDay(timestamp) {
  const date = new Date(timestamp);
  const day = date.getUTCDate();

  return day % 2 === 0 ? "even" : "odd";
}
```
