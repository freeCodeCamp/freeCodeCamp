{
  "name": "Big O Notation",
  "order": 4,
  "time": "30 minutes",
  "challenges": [
    {
      "id": "56b15f15632298c12f31517b",
      "title": "Big O Notation: What It Is and Why You Should Care",
      "description": [
        "Time complexity is a way of discussing how long specific algorithms take. This is useful in streamlining software so it works as fast as possible.",
        "When you're writing code, you should be aware of how long it's going to take to execute. Nobody wants to create a product that users find frustrating due to slow use.",
        "Time complexity is talked about in relation to an algorithm, a collection of one or more functions.",
        "Big O Notation specifically helps you identify when an algorithm wouldn't 'scale' well, or work well with varying amounts of users, information, or other inputs.",
        "This does NOT correspond with Moore's law - no matter how big and fast your computer is, if the algorithm is exponentially inefficient, it's realistically unusable.",
        "Additionally, questions about Big O Notation and time complexity can be used as interview questions.",
        "Your employers will want to know that the code you write will not take too long to load on the page for the users, and knowledge of Big O Notation shows that you're cognizant of that while writing your code.",
        "The take-away from this video is that Big O Notation helps you identify where there could be problems (sometimes BIG problems) in speed and memory when your site or app grows."
      ],
      "challengeSeed": [
        "KSNx22U4uWE"
      ],
      "tests": [
        [
          "If an algorithm is efficient for small amounts of data, it will be equally efficient for large amounts of data.",
          false,
          "It depends on the algorithm and the data it's processing."
        ],
        [
          "Big O Notation reflects the speed of an algorithm in terms of the expected input.",
          true
        ]
      ],
      "type": "hike",
      "challengeType": 6,
      "translations": {
        "es": {
          "title": "Notación O mayúscula: ¿Qué es y porque te debe interesar?",
          "description": [
            "La complejidad temporal es una forma de discutir cunto tiempo toma un algoritmo específico.  Esto es útil al ajustar software para que opere tan rápido como sea posible.",
            "Cuando escribes código, debes tener en cuenta cuanto se va a demorar su ejecución. Nadie quiere crear un producto que fruste a los usuarios por su lentitud.",
            "Se habla de complejidad temporal en relación con un algoritmo, una colección de una o más funciones.",
            "La notación O mayúscula ayuda a identificar de manera específica cuando un algoritmo no 'escalaría' bien, o no funcionaría bien con una cantidad que varia de usuarios, de información o de algún otro recurso.",
            "Esto no tiene correspondencia con la ley de Moore - no importa cuando grande y rápido sea tu computador, si un algoritmo es exponencialmente ineficiente, en realidad no es utilizable.",
            "Además, pueden haber preguntas en entrevistas sobre la notación O mayúscula y de complejidad temporal.",
            "Tu empleador podrá querer saber que el código que escribes no tardará demasiado en cargar en la página de los usuarios, y el conocimiento de la notación O mayúscula muestra que reconoces esto mientras escribies tu código.",
            "Lo que esperamos que te quede de este video es que la notación O mayúscula te ayuda a identificar cuando podría haber problemas (en ocasiones problemas MAYÚSCULOS) en velocidad y memoria cuando tu sitio o aplicación crezcan."
          ]
        }
      }
    },
    {
      "id": "56b15f15632298c12f31517a",
      "title": "Big O Notation: A Few Examples",
      "description": [
        "Time complexity is commonly estimated by counting the number of elementary operations (elementary operation = an operation that takes a fixed amount of time to perform) performed in the algorithm.",
        "Time complexity is classified by the nature of the function O(n). O represents the function, and (n) represents the number of elements to be acted on.",
        "Worst-case time complexity, the longest it could possibly take with any valid input, is the most common way to express time complexity.",
        "When you discuss Big-O notation, that is generally referring to the worst case scenario.",
        "For example, if we have to search two lists for common entries, we will calculate as if both entries would be at the very end of each list, just to be safe that we don't underestimate how long it could take.",
        "O(1) - determining if a number is odd or even. O(1) is a static amount of time, the same no matter how much information is there or how many users there are.",
        "O(log N) - finding a word in the dictionary (using binary search). Binary search is an example of a type of 'divide and conquer' algorithm.",
        "O(N) - reading a book",
        "O(N log N) - sorting a deck of playing cards (using merge sort)",
        "O(N^2) - checking if you have everything on your shopping list in your cart",
        "O(infinity) - tossing a coin until it lands on heads",
        "As a rule of thumb, anything with N^2 or any other exponent is NOT a good algorithm for a site with multiple users.",
        "If your algorithm slows down exponentially with the input, you're going to want to look for a more efficient way to solve that problem.",
        "Whenever you’re coding loops within loops, you want to be especially mindful of time complexity.",
        "Big O Cheat Sheet is the place to look once you can classify your algorithm, like as a 'merge-sort' or a 'quick-sort'.",
        "<a href='http://bigocheatsheet.com/' target='_blank'>bigocheatsheet.com/</a>",
        "Princeton Coursera course is NOT for the faint of heart. With examples and practice in Java, this course will cover iterating over data specifically with Java, sorting, and searching algorithms.",
        "<a href='http://coursera.org/course/algs4partI' target='_blank'>coursera.org/course/algs4partI</a>"
      ],
      "challengeSeed": [
        "-Eiw_-v__Vo"
      ],
      "tests": [
        [
          "Algorithms expressed exponentially like O(C^N), where C is a constant can work well in certain situations, so you shouldn't avoid them completely.",
          false,
          "While they can work in certain small scale situations, they aren't good practice because they will not work larger scale."
        ],
        [
          "All algorithms can be broken down to complete in a static amount of time if you do it effectively.",
          false,
          "Not all algorithms can be simplified to that extent, but you should always try to find the simplest way to solve your problem."
        ]
      ],
      "type": "hike",
      "challengeType": 6,
      "translations": {
        "es": {
          "title": "Notación O mayúscula: Unos pocos ejemplos",
          "description": [
            "La complejidad en tiempo comunmente se estima contando la cantidad de operaciones elementales que un algoritmo efectua (una operación elemental es una cuya ejecución requiere una cantidad de tiempo fijo).",
            "La complejidad temporal se clasifica por la naturaleza de la función O(n) donde O representa una función matemática para el tiempo que tarda el algoritmo y n representa la cantidad de elementos sobre los que actua el algoritmo.",
            "La complejidad en el peor caso, es la que más se demoraría con una entrada válida, es la forma más comun de expresar la complejidad.",
            "Cuando discutes la notación O mayúscula, esta se refiere al peor caso.",
            "Por ejemplo, si debemos buscar elementos comunes en dos listas, haremos el cálculo suponiendo que los elementos comunes estuvieran justamente al final de cada una de las lista, para no subestimar cuando nos tomaría encontrarlos.",
            "O(1) - por ejemplo determinar si un número es par o impar, tarda lo mismo sin importar cuanta información haya o cuantos usuarios haya.",
            "O(log N) - encontrar una palabra en un diccionario (utilizando búsqueda binaria). La búsqueda binaria es un ejemplo de un tipo de algoritmo 'divide y vencerás'.",
            "O(N) - leer un libro",
            "O(N log N) - ordenar una plia de cartas (usando ordenamiento por mezcla)",
            "O(N^2) - revisar que todo lo de una lista de compras está en el carrito de compras",
            "O(infinito) - lanzar una moneda hasta que caiga cara",
            "Como regla, todo lo que sea N^2 o cualquier exponente mayor no es un buen algoritmo para un sitio con muchos usuarios.",
            "Si tu algoritmo se hace más lento de manera exponencial a medida que aumenta la entrada, querrás buscar una forma más eficiente de resolver el problema.",
            "Siempre que programes ciclos dentro de ciclos, querrás ser especialmente cuidadoso de la complejidad temporal.",
            "La hoja de copialina de la notación O mayúscula es el lugar donde mirar para clasificar tu algoritmo, como el de un 'ordenamiento por mezcla' o un 'ordenamiento rápido'.",
            "<a href='http://bigocheatsheet.com/' target='_blank'>bigocheatsheet.com/</a>",
            "El curso de Coursera de Princeton no es para débiles de corazón. Con ejemplos y prácticas en Java, este curso cubre iteración sobre los datos especifcamente algoritmos de ordenamiento y búsqueda.",
            "<a href='http://coursera.org/course/algs4partI' target='_blank'>coursera.org/course/algs4partI</a>"
          ]
        }
      }
    }
  ]
}
