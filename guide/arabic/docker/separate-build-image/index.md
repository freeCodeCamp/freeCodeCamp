---
title: Separate Build Image
localeTitle: صورة بناء منفصلة
---
## نظرة عامة

جعل صور عامل ميناء خفيفة الوزن هو مفتاح وجود خط أنابيب سريع التطوير / النشر. بالنسبة إلى الشفرات المترجمة ، فإن بناء الملف الثنائي داخل حاوية عامل ميناء له فائدة من كونه عملية إنشاء متكررة وموحدة. ومع ذلك ، يمكن لهذا إنشاء صور كبيرة جدًا يمكن أن تصبح مشكلة أسفل الخط.

## لدينا الكود

في هذا المثال ، سنستخدم خادمًا بسيطًا لخادم الويب في [Go](https://golang.org/) . التعليمة البرمجية التالية هي مجرد webserver hello world يستمع على المنفذ `8080` .

 `package main 
 
 import ( 
    "fmt" 
    "log" 
    "net/http" 
 ) 
 
 func handler(w http.ResponseWriter, r *http.Request) { 
    fmt.Fprint(w, "Hello world!") 
 } 
 
 func main() { 
    http.HandleFunc("/", handler) 
    log.Fatal(http.ListenAndServe(":8080", nil)) 
 } 
` 

### Dockerfile

قد يبدو Dockerfile لهذا الرمز شيء من هذا القبيل

 `FROM golang:1.11 
 
 ADD . /app 
 
 WORKDIR /app 
 
 RUN go build -o /myserver . 
 
 EXPOSE 8080 
 
 CMD [ "/myserver" ] 
` 

بناء هذه الصورة ينتج في صورة بحجم 783MB !! باستخدام صورة بهذا الحجم للتطبيق البسيط ، من السهل رؤية كيف يمكن أن يؤدي ذلك إلى إبطاء الأشياء عند النشر.

## حل أفضل

الحل الأفضل هو استخدام صورة بناء منفصلة لبناء الملف الثنائي ثم نسخه إلى الصورة النهائية. كما يولد Go بثًا مستقلاً ، يمكننا استخدام صورة docker `scratch` كقاعدة صغيرة جدًا بقدر ما تحصل عليه!

### Dockerfile

سيقوم Dockerfile التالي ببناء الثنائي داخل صورة golang ومن ثم بناء صورة جديدة من الصفر ، نسخ الملف الثنائي من الصورة الأولى إلى الثانية.

 `FROM golang:1.11 as build 
 
 ADD . /app 
 
 WORKDIR /app 
 
 RUN go build -o /myserver . 
 
 
 FROM scratch 
 
 COPY --from=build /myserver /myserver 
 
 EXPOSE 8080 
 
 CMD [ "myserver" ] 
` 

بناء من هذا dockerfile النتائج في حجم الصورة النهائية من 6.55MB فقط! هذا **أصغر** من **100 مرة** من محاولتنا الأولى ، مما يجعله أسرع 100 مرة في سحب الصورة من التسجيل!

### مكافأة منحة

ليس لدينا الآن فقط صورة رصيف صغيرة لتطبيقنا ، بل يجب علينا فقط أن نقلق بشأن أمن تطبيقنا لأنه لا يوجد برنامج آخر يعمل داخل الحاوية.